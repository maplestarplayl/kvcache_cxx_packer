name: Build and Release KVCache C++ Packages

on:
  push:
    branches: [ main, master, develop ]
    tags:
      - 'v*'  # å½“æŽ¨é€ä»¥ v å¼€å¤´çš„æ ‡ç­¾æ—¶è§¦å‘
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
    inputs:
      release_tag:
        description: 'Release tag (e.g., v0.1.0) for manual run'
        required: true
        type: string
      draft:
        description: 'Create release as draft'
        required: false
        default: false
        type: boolean
      prerelease:
        description: 'Mark release as prerelease'
        required: false
        default: false
        type: boolean
      generate_release_notes:
        description: 'Auto generate release notes'
        required: false
        default: true
        type: boolean

# æ·»åŠ æƒé™è®¾ç½®
permissions:
  contents: write
  actions: read

jobs:
  prepare_release:
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.vars.outputs.tag }}
    steps:
    - name: Compute release tag
      id: vars
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          TAG="${{ inputs.release_tag }}"
        else
          TAG="${GITHUB_REF_NAME}"
        fi
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Computed release tag: $TAG"

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Ensure draft release exists
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG='${{ steps.vars.outputs.tag }}'
        echo "Ensuring draft release for tag: $TAG"
        if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" >/dev/null 2>&1; then
          echo "Release exists."
        else
          echo "Creating draft release $TAG"
          gh release create "$TAG" --title "KVCache C++ Packages $TAG" --notes "Initializing release..." --draft --repo "$GITHUB_REPOSITORY"
        fi

  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "Ubuntu 20.04 AMD64"
            system_name: "ubuntu20.04"
            arch: "amd64"
            platform: "linux/amd64"
          
          - name: "Ubuntu 20.04 ARM64"
            system_name: "ubuntu20.04"
            arch: "arm64"
            platform: "linux/arm64"
          
          - name: "Ubuntu 22.04 AMD64"
            system_name: "ubuntu22.04"
            arch: "amd64"
            platform: "linux/amd64"
          
          - name: "Ubuntu 22.04 ARM64"
            system_name: "ubuntu22.04"
            arch: "arm64"
            platform: "linux/arm64"
          
          - name: "ManyLinux 2014 AMD64"
            system_name: "manylinux_2014"
            arch: "amd64"
            platform: "linux/amd64"
          
          - name: "ManyLinux 2014 ARM64"
            system_name: "manylinux_2014"
            arch: "arm64"
            platform: "linux/arm64"
    
    runs-on: ubuntu-latest

    name: Build on ${{ matrix.name }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.8'
    
    # è®¾ç½® QEMU ä»¥æ”¯æŒå¤šæž¶æž„æž„å»º
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: ${{ matrix.platform }}
    
    # è®¾ç½® Docker Buildxï¼ˆè™½ç„¶æˆ‘ä»¬ä¸ç”¨ buildx æž„å»ºï¼Œä½†å®ƒæä¾›äº†æ›´å¥½çš„å¤šæž¶æž„æ”¯æŒï¼‰
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
        
    - name: Verify Docker availability
      run: |
        # GitHub runners already have Docker available
        # Avoid using systemctl which isn't available on runners
        docker --version
        if ! docker info > /dev/null 2>&1; then
          echo "Docker daemon not available"
          exit 1
        fi
        
        # éªŒè¯ QEMU å’Œå¤šæž¶æž„æ”¯æŒ
        echo "Checking available platforms:"
        docker buildx ls
        
    - name: Build Packages using Container
      run: |
        # æ˜¾ç¤ºç³»ç»Ÿä¿¡æ¯
        echo "Building for system: ${{ matrix.system_name }}"
        echo "Target architecture: ${{ matrix.arch }}"
        echo "Host architecture: $(uname -m)"
        echo "Docker platform: ${{ matrix.platform }}"
        
        # ä½¿ç”¨ pack_in_container.py è„šæœ¬è¿›è¡Œæž„å»ºï¼ŒæŒ‡å®šæž¶æž„
        python3 pack_in_container.py --system-name ${{ matrix.system_name }} --arch ${{ matrix.arch }}
        
    - name: Package Build Output
      run: |
        # æ£€æŸ¥ .output ç›®å½•æ˜¯å¦å­˜åœ¨å†…å®¹
        if [ -d ".output" ] && [ "$(ls -A .output)" ]; then
          echo "âœ… Found build output in .output directory:"
          ls -la .output/
          
          # ä½¿ç”¨ matrix ä¸­æŒ‡å®šçš„æž¶æž„ï¼Œè€Œä¸æ˜¯ä¸»æœºæž¶æž„
          ARCH="${{ matrix.arch }}"
          
          # åˆ›å»ºtaråŒ…æ–‡ä»¶å
          TAR_NAME="output_${{ matrix.system_name }}_${ARCH}.tar.gz"
          
          # æ‰“åŒ… .output ç›®å½•å†…å®¹åˆ°å½“å‰ç›®å½•ï¼ˆé¿å…é€’å½’æ‰“åŒ…ï¼‰
          tar -czf "${TAR_NAME}" -C .output .
          
          # ç§»åŠ¨taræ–‡ä»¶åˆ° .output ç›®å½•
          mv "${TAR_NAME}" .output/
          
          echo "âœ… Created package: ${TAR_NAME}"
          echo "Package size: $(du -h .output/${TAR_NAME} | cut -f1)"
        else
          echo "âŒ No build output found in .output directory"
          exit 1
        fi
        
    - name: Verify Build Output
      run: |
        # åˆ—å‡ºç”Ÿæˆçš„æ–‡ä»¶
        ls -la .output/
        ls -la .output_logs/
        
        # æ£€æŸ¥ç”Ÿæˆçš„tar.gzæ–‡ä»¶
        if ls .output/output_*.tar.gz 1> /dev/null 2>&1; then
          echo "âœ… Found output package files:"
          ls -la .output/output_*.tar.gz
        else
          echo "âŒ No output package files found"
          exit 1
        fi
        
        # æ˜¾ç¤ºæž„å»ºæŠ¥å‘Š
        if [ -f .output_logs/build_report.txt ]; then
          echo "=== Build Report ==="
          cat .output_logs/build_report.txt
        fi
        
        if [ -f .output_logs/build_report.json ]; then
          echo "Build report exists"
          
          # æ£€æŸ¥æž„å»ºæ˜¯å¦æˆåŠŸ - ä½¿ç”¨å•è¡ŒPythonè„šæœ¬
          if python3 -c "import json; report = json.load(open('.output_logs/build_report.json')); failed = [pkg for pkg, result in report.items() if not result.get('success', False)]; exit(1 if failed else 0)"; then
            echo "âœ… All packages built successfully"
          else
            echo "âŒ Some packages failed to build"
            python3 -c "import json; report = json.load(open('.output_logs/build_report.json')); failed = [pkg for pkg, result in report.items() if not result.get('success', False)]; print(f'Failed packages: {failed}') if failed else None"
            exit 1
          fi
        else
          echo "âŒ Build report not found"
          exit 1
        fi
        
    - name: Generate checksums
      run: |
        # ä¸ºç”Ÿæˆçš„åŒ…æ–‡ä»¶ç”Ÿæˆ SHA256 æ ¡éªŒå’Œ
        cd .output
        for file in output_*.tar.gz; do
          if [ -f "$file" ]; then
            sha256sum "$file" > "$file.sha256"
            echo "Generated checksum for $file:"
            cat "$file.sha256"
          fi
        done

    - name: Upload assets to GitHub Release
      if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) || github.event_name == 'workflow_dispatch'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        RELEASE_TAG: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.ref_name }}
      run: |
        echo "Uploading assets for $RELEASE_TAG"
        ls -la .output/
        # Upload tarballs and checksums; --clobber allows re-runs to overwrite
        gh release upload "$RELEASE_TAG" .output/output_*.tar.gz .output/output_*.tar.gz.sha256 --clobber --repo "$GITHUB_REPOSITORY"
        
    # Artifacts are uploaded directly to the Release; no need to upload to Actions artifacts

    - name: Upload Build Logs on Failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-logs-${{ matrix.system_name }}-${{ github.sha }}
        path: |
          .output_logs/
          .output/build_summary.txt
        retention-days: 7

  # Finalize/publish release (no artifact download needed)
  finalize_release:
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) || github.event_name == 'workflow_dispatch'
    needs: [prepare_release, build]
    runs-on: ubuntu-latest
    steps:
    - name: Generate release notes from uploaded assets
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        RELEASE_TAG: ${{ needs.prepare_release.outputs.tag }}
      run: |
        echo "Generating release notes for $RELEASE_TAG"
        # List assets via GitHub API
        ASSETS=$(gh release view "$RELEASE_TAG" --repo "$GITHUB_REPOSITORY" --json assets --jq '.assets[].name' || true)
        {
          echo "## KVCache C++ Packages Release $RELEASE_TAG"
          echo
          echo "This release contains pre-built C++ packages for multiple systems and architectures."
          echo
          echo "### ðŸ“¦ Available Packages:"
          echo "$ASSETS" | awk 'NF{print "- `"$0"`"}'
          echo
          cat <<'MD'
        ### ðŸ“š Included Libraries:
        - etcd-cpp-apiv3 (master branch)
        - gflags (master branch)
        - glog (v0.6.0)
        - jsoncpp (master branch)
        - rdma-core (master branch)
        - yalantinglibs (main branch)
        
        ### ðŸš€ Usage:
        1. Verify integrity: `sha256sum -c output_{system}_{arch}.tar.gz.sha256`
        2. Extract: `tar -xzf output_{system}_{arch}.tar.gz`
        3. Add to your CMake project:
           ```cmake
           set(CMAKE_PREFIX_PATH "/path/to/extracted" ${CMAKE_PREFIX_PATH})
           find_package(YourPackage REQUIRED)
           ```
        
        ### ðŸ”§ Build Information:
        - Multiple system support: Ubuntu 20.04, Ubuntu 22.04, ManyLinux 2014
        - Compiled with GCC 10
        - C++17/C++20 standard support
        - Static libraries included
        - Built using Docker containers for isolation and consistency
        
        ### ðŸ” Security:
        SHA256 checksums are provided for integrity verification.
        MD
        } > release-notes.md

        echo "Release notes preview:"
        cat release-notes.md

    - name: Publish or update release
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        RELEASE_TAG: ${{ needs.prepare_release.outputs.tag }}
        IS_MANUAL: ${{ github.event_name == 'workflow_dispatch' }}
        INPUT_DRAFT: ${{ inputs.draft }}
        INPUT_PRERELEASE: ${{ inputs.prerelease }}
      run: |
        if [ "$IS_MANUAL" = "true" ]; then
          DRAFT="$INPUT_DRAFT"; PRERELEASE="$INPUT_PRERELEASE"
        else
          DRAFT="false"; PRERELEASE="false"
        fi
        echo "Finalizing release $RELEASE_TAG (draft=$DRAFT, prerelease=$PRERELEASE)"
        gh release edit "$RELEASE_TAG" --repo "$GITHUB_REPOSITORY" \
          --title "KVCache C++ Packages $RELEASE_TAG" \
          --notes-file release-notes.md \
          --draft="$DRAFT" \
          --prerelease="$PRERELEASE"
